命令模式是一个高内聚的模式
    将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能


其中的几个角色
    Receiver接受者角色：就是具体的干活的角色，具体到例子中的就是Group的三个实现类
    Command命令角色：需要执行的所有命令都在这里声明，具体到上面的三个Command的子类 （为了防止子类的膨胀，可以采用模板的设计模式）
    Invoker调用者角色：接收到命令（ setCommand() ）。并执行命令( action() )。

命令模式的优点
    类间解耦
        调用者角色和接受者角色之间没有任何依赖关系, 调用者实现功能时只需要调用Command抽象类的execute方法就可以。 不需要了解到底是哪个接受者执行。
    可扩展性
        Command的子类可以非常容易的扩展，调用者Invoker和高层次的模块Client不产生严重的代码耦合
    命令模式结合其他的模式会更优秀
        命令模式和责任链模式实现命令族解析任务；
        结合模板方法模式，则可以减少Command子类的膨胀问题


命令模式的缺点
    Command子类膨胀的很大，在有些情况下。慎重考虑使用。


命令模式的使用场景
    只要你认为是命令的地方就可以采用命令模式， 例如：在GUI开发中，一个按钮的点击是一个命令， 可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模式
    ；触发-反馈机制的处理等， 这里可以结合GWMS的触发反馈机制说一下应用的情况。

返回问题的实现 （一般指的是逆操作， 如撤销等）
    比如撤销某一个命令， 则在Group中添加一个公用方法即可，（不是抽象方法）


具体的实践： 任务的创建可以用作命令的模式， 每种任务的创建都可以定义一种特定的命令， 比如拣货任务和打包任务； 再定义一个命令的接收者，统一的任务的创建者，完美！