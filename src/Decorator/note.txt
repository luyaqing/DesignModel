
装饰器模式
    一种比较常见的模式：动态的给一个对象添加一些额外的职责。 就增加功能来说，装饰模式相比生成子类更为灵活。

    Component抽象构件
        是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。


    ConcreteComponent具体构件
        上面的实现，你要装饰的就是这个对象

    Decorator 装饰角色
        一般是抽象类，实现接口或者抽象方法，它的属性里必然有一个private变量指向Component抽象构件。

    具体装饰角色
    ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类

    注意： 原始方法和装饰方法的执行顺序在具体的装饰类是固定的， 可以通过方法重载实现多种执行顺序。


    优点：
        装饰类和被装饰类可以独立发展，而不会相互耦合
        装饰模式时候继承关系一个替代方案。
        装饰模式可以动态的扩展一个实现类的功能

    缺点：
        多层的装饰是比较复杂的，想想看，就想剥洋葱一样，你报道了最后才发现是最里层的装饰出现了问题，因此尽量减少装饰类的数量，以便降低系统的复杂度


    使用场景：
        需要扩展一个类的功能，或给一个类增加附加功能
        需要动态的给一个对象增加功能， 这些功能可以再动态的撤销
        需要为一批的兄弟类进行改造或加装功能，当然是首选装饰模式

