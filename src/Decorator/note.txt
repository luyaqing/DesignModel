
装饰器模式
    一种比较常见的模式：动态的给一个对象添加一些额外的职责。 就增加功能来说，装饰模式相比生成子类更为灵活。

    Component抽象构件
        是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象。


    ConcreteComponent具体构件
        上面的实现，你要装饰的就是这个对象

    Decorator 装饰角色
        一般是抽象类，实现接口或者抽象方法，它的属性里必然有一个private变量指向Component抽象构件。

    具体装饰角色
    ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类

    注意： 原始方法和装饰方法的执行顺序在具体的装饰类是固定的， 可以通过方法重载实现多种执行顺序。


    优点：
        装饰类和被装饰类可以独立发展，而不会相互耦合
        装饰模式是继承关系的一个替代方案。
        装饰模式可以动态的扩展一个实现类的功能

    缺点：
        多层的装饰是比较复杂的，想想看，就想剥洋葱一样，你剥到了最后才发现是最里层的装饰出现了问题，因此尽量减少装饰类的数量，以便降低系统的复杂度


    使用场景：
        需要扩展一个类的功能，或给一个类增加附加功能
        需要动态的给一个对象增加功能， 这些功能可以再动态的撤销
        需要为一批的兄弟类进行改造或加装功能，当然是首选装饰模式

    代码中的具体的实现：
                        mybatis中的缓存的设计还有：当Mybatis开启二级缓存时， 会使用cachingExecutor对象对SimpleExecutor、
    ReuseExecutor、BatchExecutor进行装饰， 为查询操作增加二级缓存功能，这是装饰器模式的应用。

                        Mybatis中的缓存类采用装饰器模式设计，Cache接口有一个基本的实现类，PerpetualCache，为了对这个类的功能进行增强，提供了
                        一些缓存的装饰器类（10种）

